
from xml.dom.minidom import getDOMImplementation
from systemrdl.node import RootNode, AddressableNode, RegNode
from systemrdl.node import AddrmapNode, RegfileNode, MemNode
from systemrdl import rdltypes

class IPXACTExporter:
    def __init__(self, node, path, options):
        self.top_node = node
        self.path = path
        
        self.vendor = options.pop("vendor", "example.org")
        self.library = options.pop("library", "mylibrary")
        self.version = options.pop("version", "1.0")
        
        self.reg_accesswidth = None
        
        # Check for stray options
        if options:
            raise TypeError("got an unexpected keyword argument '%s'" % list(options.keys())[0])
        
        # If it is the root node, skip to top addrmap
        if isinstance(self.top_node, RootNode):
            self.top_node = self.top_node.top
        
        if not isinstance(self.top_node, AddrmapNode):
            raise TypeError("'node' argument expects type AddrmapNode. Got '%s'" % type(node).__name__)
        
        # Initialize XML DOM
        self.doc = getDOMImplementation().createDocument(None, None, None)
        
    #---------------------------------------------------------------------------
    def run(self):
        tmp = self.doc.createComment("Generated by RALBot IP-XACT")
        self.doc.appendChild(tmp)
        
        # Create top-level component
        comp = self.doc.createElement("ipxact:component")
        comp.setAttribute("xmlns:ipxact", "http://www.accellera.org/XMLSchema/IPXACT/1685-2014")
        comp.setAttribute("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance")
        comp.setAttribute("xsi:schemaLocation", "http://www.accellera.org/XMLSchema/IPXACT/1685-2014 http://www.accellera.org/XMLSchema/IPXACT/1685-2014/index.xsd")
        self.doc.appendChild(comp)
        
        # versionedIdentifier Block
        self.add_value(comp, "ipxact:vendor", self.vendor)
        self.add_value(comp, "ipxact:library", self.library)
        self.add_value(comp, "ipxact:name", self.top_node.inst.inst_name)
        self.add_value(comp, "ipxact:version", self.version)
        
        mmaps = self.doc.createElement("ipxact:memoryMaps")
        comp.appendChild(mmaps)
        mmap = self.doc.createElement("ipxact:memoryMap")
        self.add_nameGroup(mmap, "%s_mmap" % self.top_node.inst.inst_name)
        mmaps.appendChild(mmap)
        
        self.add_addressBlock(mmap, self.top_node)
        
        with open(self.path, "w") as f:
            self.doc.writexml(f, addindent="  ", newl="\n", encoding="UTF-8")
        
    #---------------------------------------------------------------------------
    def add_value(self, parent, tag, value):
        el = self.doc.createElement(tag)
        txt = self.doc.createTextNode(value)
        el.appendChild(txt)
        parent.appendChild(el)
    
    #---------------------------------------------------------------------------
    def add_nameGroup(self, parent, name, displayName=None, description=None):
        self.add_value(parent, "ipxact:name", name)
        if displayName is not None:
            self.add_value(parent, "ipxact:displayName", displayName)
        if description is not None:
            self.add_value(parent, "ipxact:description", description)
    
    #---------------------------------------------------------------------------
    def add_addressBlock(self, parent, node):
        addressBlock = self.doc.createElement("ipxact:addressBlock")
        parent.appendChild(addressBlock)
        
        self.add_nameGroup(addressBlock,
            node.inst.inst_name,
            node.get_property("name", default=None),
            node.get_property("desc")
        )
        
        if not node.get_property("ispresent"):
            self.add_value(addressBlock, "ipxact:isPresent", "0")
        
        self.add_value(addressBlock, "ipxact:baseAddress", "%d" % node.absolute_address)
        
        # DNE: <ipxact:typeIdentifier>
        
        self.add_value(addressBlock, "ipxact:range", "%d" % node.size)
        
        # RDL only encodes the bus-width at the register level, but IP-XACT
        # only encodes this at the addressBlock level!
        # Insert the with element for now, but leave contents blank until it is
        # determined later.
        # Exporter has no choice but to enforce a constant width throughout
        width_el = self.doc.createElement("ipxact:width")
        addressBlock.appendChild(width_el)
        
        # DNE: <ipxact:usage>
        # DNE: <ipxact:volatile>
        # DNE: <ipxact:access>
        # DNE: <ipxact:parameters>
        
        for child in node.children(skip_not_present=False):
            if isinstance(child, RegNode):
                self.add_register(addressBlock, child)
            if isinstance(child, (AddrmapNode, RegfileNode, MemNode)):
                self.add_registerFile(addressBlock, child)
        
        # Width is now known!
        if self.reg_accesswidth is not None:
            width_el.appendChild(self.doc.createTextNode("%d" % self.reg_accesswidth))
        else:
            width_el.appendChild(self.doc.createTextNode("32"))
        
        # DNE: <ipxact:vendorExtensions>
    
    #---------------------------------------------------------------------------
    def add_registerFile(self, parent, node):
        registerFile = self.doc.createElement("ipxact:registerFile")
        parent.appendChild(registerFile)
        
        self.add_nameGroup(registerFile,
            node.inst.inst_name,
            node.get_property("name", default=None),
            node.get_property("desc")
        )
        
        if not node.get_property("ispresent"):
            self.add_value(registerFile, "ipxact:isPresent", "0")
        
        if node.inst.is_array:
            for dim in node.inst.array_dimensions:
                self.add_value(registerFile, "ipxact:dim", "%d" % dim)
        
        self.add_value(registerFile, "ipxact:addressOffset", "%d" % node.inst.addr_offset)
        
        # DNE: <ipxact:typeIdentifier>
        
        if node.inst.is_array:
            # For arrays, ipxact:range also defines the increment between indexes
            # Must use stride instead
            self.add_value(registerFile, "ipxact:range", "%d" % node.inst.array_stride)
        else:
            self.add_value(registerFile, "ipxact:range", "%d" % node.size)
        
        for child in node.children(skip_not_present=False):
            if isinstance(child, RegNode):
                self.add_register(registerFile, child)
            if isinstance(child, (AddrmapNode, RegfileNode, MemNode)):
                self.add_registerFile(registerFile, child)
        
        # DNE: <ipxact:parameters>
        # DNE: <ipxact:vendorExtensions>
        
    #---------------------------------------------------------------------------
    def add_register(self, parent, node):
        register = self.doc.createElement("ipxact:register")
        parent.appendChild(register)
        
        self.add_nameGroup(register,
            node.inst.inst_name,
            node.get_property("name", default=None),
            node.get_property("desc")
        )
        
        if not node.get_property("ispresent"):
            self.add_value(register, "ipxact:isPresent", "0")
        
        if node.inst.is_array:
            for dim in node.inst.array_dimensions:
                self.add_value(register, "ipxact:dim", "%d" % dim)
        
        self.add_value(register, "ipxact:addressOffset", "%d" % node.inst.addr_offset)
        
        # DNE: <ipxact:typeIdentifier>
        
        self.add_value(register, "ipxact:size", "%d" % node.get_property("regwidth"))
        
        if self.reg_accesswidth is None:
            self.reg_accesswidth = node.get_property("accesswidth")
        else:
            if node.get_property("accesswidth") != self.reg_accesswidth:
                # ipxact only supports a constant block register width
                raise ValueError("Block contains more than one accesswidth of registers. Unable to export")
            
        # DNE: <ipxact:volatile>
        # DNE: <ipxact:access>
        
        for field in node.fields(skip_not_present=False):
            self.add_field(register, field)
            
        # DNE <ipxact:alternateRegister> [...]
        # DNE: <ipxact:parameters>
        # DNE: <ipxact:vendorExtensions>
    
    #---------------------------------------------------------------------------
    def add_field(self, parent, node):
        field = self.doc.createElement("ipxact:field")
        parent.appendChild(field)
        
        self.add_nameGroup(field,
            node.inst.inst_name,
            node.get_property("name", default=None),
            node.get_property("desc")
        )
        
        if not node.get_property("ispresent"):
            self.add_value(field, "ipxact:isPresent", "0")
        
        self.add_value(field, "ipxact:bitOffset", "%d" % node.inst.low)
        
        reset = node.get_property("reset")
        if reset is not None:
            resets_el = self.doc.createElement("ipxact:resets")
            field.appendChild(resets_el)
            reset_el = self.doc.createElement("ipxact:reset")
            resets_el.appendChild(reset_el)
            self.add_value(reset_el, "ipxact:value", "%d" % reset)
        
        # DNE: <ipxact:typeIdentifier>
        
        self.add_value(field, "ipxact:bitWidth", "%d" % node.inst.width)
        
        if node.is_volatile:
            self.add_value(field, "ipxact:volatile", "true")
        
        sw = node.get_property("sw")
        if sw == rdltypes.AccessType.r:
            self.add_value(field, "ipxact:access", "read-only")
        elif sw == rdltypes.AccessType.rw:
            self.add_value(field, "ipxact:access", "read-write")
        elif sw == rdltypes.AccessType.rw1:
            self.add_value(field, "ipxact:access", "read-writeOnce")
        elif sw == rdltypes.AccessType.w:
            self.add_value(field, "ipxact:access", "write-only")
        elif sw == rdltypes.AccessType.w1:
            self.add_value(field, "ipxact:access", "writeOnce")
        
        encode = node.get_property("encode")
        if encode is not None:
            enum_values_el = self.doc.createElement("ipxact:enumeratedValues")
            field.appendChild(enum_values_el)
            for enum_value in encode:
                enum_value_el = self.doc.createElement("ipxact:enumeratedValue")
                enum_values_el.appendChild(enum_value_el)
                self.add_nameGroup(enum_value_el,
                    enum_value.name,
                    enum_value.rdl_name,
                    enum_value.rdl_desc
                )
                self.add_value(enum_value_el, "ipxact:value", "%d" % enum_value.value)
                # DNE <ipxact:vendorExtensions>
                
        onwrite = node.get_property("onwrite")
        if onwrite == rdltypes.OnWriteType.wclr:
            self.add_value(field, "ipxact:modifiedWriteValue", "clear")
        elif onwrite == rdltypes.OnWriteType.woclr:
            self.add_value(field, "ipxact:modifiedWriteValue", "oneToClear")
        elif onwrite == rdltypes.OnWriteType.woset:
            self.add_value(field, "ipxact:modifiedWriteValue", "oneToSet")
        elif onwrite == rdltypes.OnWriteType.wot:
            self.add_value(field, "ipxact:modifiedWriteValue", "oneToToggle")
        elif onwrite == rdltypes.OnWriteType.wset:
            self.add_value(field, "ipxact:modifiedWriteValue", "set")
        elif onwrite == rdltypes.OnWriteType.wuser:
            self.add_value(field, "ipxact:modifiedWriteValue", "modify")
        elif onwrite == rdltypes.OnWriteType.wzc:
            self.add_value(field, "ipxact:modifiedWriteValue", "zeroToClear")
        elif onwrite == rdltypes.OnWriteType.wzs:
            self.add_value(field, "ipxact:modifiedWriteValue", "zeroToSet")
        elif onwrite == rdltypes.OnWriteType.wzt:
            self.add_value(field, "ipxact:modifiedWriteValue", "zeroToToggle")
        
        # DNE: <ipxact:writeValueConstraint>
        
        onread = node.get_property("onread")
        if onwrite == rdltypes.OnReadType.rclr:
            self.add_value(field, "ipxact:readAction", "clear")
        elif onwrite == rdltypes.OnReadType.rset:
            self.add_value(field, "ipxact:readAction", "set")
        elif onwrite == rdltypes.OnReadType.ruser:
            self.add_value(field, "ipxact:readAction", "modify")
        
        if node.get_property("donttest"):
            self.add_value(field, "ipxact:testable", "false")
        
        # DNE: <ipxact:reserved>
        
        # DNE: <ipxact:parameters>
        # DNE: <ipxact:vendorExtensions>

#===============================================================================
def export(node, path, **kwargs):
    x = IPXACTExporter(node, path, kwargs)
    x.run()
